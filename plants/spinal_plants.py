"""
spinal_plants.py
The plant models specially adapted for the spinal model.
"""
from draculab import unit_types, synapse_types, syn_reqs 
#from units.units import unit, sigmoidal
from plants.plants import (plant, pendulum, spring_muscle, hill_muscle,
planar_arm, planar_arm_v2, planar_arm_v3)
import numpy as np
from numpy import sin, cos # for the double pendulum equations


class bouncy_pendulum(pendulum):
    """ 
    A pendulum that bounces away when its angle approaches pi.

    This is a variation of the pendulum class with a modified derivatives
    function. It causes a torque that bounces the pendulum away when its angle
    approaches pi radians. It can also be made less bouncy by increasing the
    viscous friction coefficient as the angle approaches pi. This behaviour
    depends on a parameter called pi_visco.

    PENDULUM DOCSTRING:
    Model of a rigid, homogeneous rod with a 1-dimensional rotational joint at one end.

    The simplest model of an arm is a rigid rod with one end attached to a rotational
    joint with 1 degree of freedom. Like a rigid pendulum, but the gravity vector is
    optional. 
    There is no extra mass at the end of the rod; the center of mass is at length/2 .
    
    On the XY plane the joint is at the origin, the positive X direction
    aligns with zero degrees, and gravity points in the negative Y direction.
    Counterclockwise rotation and torques are positive. Angles are in radians, time is
    in seconds.

    The equation of motion used is: I a = (mgL/2)cos(theta) - mu v + T
    where I=inertia moment about axis of rotation, a=angular acceleration, g=gravity constant,
    L=length of rod, theta=pendulum angle, mu=viscous friction coefficeint, m=mass of rod, 
    v=angular velocity, T=external torque.

    Inputs to the model at port 0 are torques applied at the joint. Other ports are ignored.

    The get_state(time) function returns the two state variables of the model in a numpy 
    array. Angle has index 0, and angular velocity has index 1. The 'time' argument
    should be in the interval [sim_time - del, sim_time], where sim_time is the current
    simulation time (time of last simulation step), and del is the 'delay' value
    of the plant. This method can be configured to provide angles in the 
    [-pi, pi) interval by using the 'bound_angle' parameter.

    Alternatively, the state variables can be retrieved with the get_angle(t) and
    get_ang_vel(t) functions.
    """
    def __init__(self, ID, params, network):
        """ The class constructor, called by network.create_plant .

        Args:
            ID: An integer serving as a unique identifier in the network.
            params: A dictionary with parameters to initialize the model.
                REQUIRED PARAMETERS
                'type' : A model from the plant_models enum.
                'length' : length of the rod [m]
                'mass' : mass of the rod [kg]
                'init_angle' : initial angle of the rod. [rad]
                'init_ang_vel' : initial angular velocity of the rod. [rad/s]
                OPTIONAL PARAMETERS
                'g' : gravitational acceleration constant. [m/s^2] (Default: 9.8)
                'inp_gain' : A gain value that multiplies the inputs. (Default: 1)
                'mu' : A viscous friction coefficient. (Default: 0)
                'bound_angle' : If True, the angle communicated through the output
                                ports is in the interval [-pi, pi). False by default.
                'pi_visco' : a gain value that multiplies the viscosity
                             generated by proximity to the angle pi. Default is 
                             0, which makes the arm bouncy.
            network: the network where the plant instance lives.

        Raises:
            AssertionError.

        """
        pendulum.__init__(self, ID, params, network)
        if 'pi_visco' in params:
            self.pi_visco = params['pi_visco']
        else:
            self.pi_visco = 0.
 
    def derivatives(self, y, t):
        """ Returns the derivatives of the state variables at a given point in time. 

	Args:
            y[0] = angle [radians]
            y[1] = angular velocity [radians / s]
            t = time at which the derivative is evaluated [s]
        Returns:
            2-element 1D Numpy array with angular velocity and acceleration.
        """
        # the inputs generate torque
        torque = self.inp_gain * self.get_input_sum(t,0)
        # torque will also appear when angle is close to pi
        torque -= (np.tan((y[0]%(2.*np.pi))/2.)/10.)**3
        # extra viscosity appears close to pi
        mupi = self.pi_visco / (((y[0]+np.pi)%(2.*np.pi))**2 + 1e-5)
        # torque may also come from gravity and friction
        torque -= self.c * np.cos(y[0]) +  (self.mu + mupi) * y[1]
        # angular acceleration = torque / (inertia moment)
        ang_accel = torque / self.I
        return np.array([y[1], ang_accel])


class bouncy_planar_arm(planar_arm):
    """ A version of the planar arm with bounded angles.

        For both the shoulder and elbow joints there are maximum and minimum
        angles, set by extra parameters in the constructor. These angles are
        enforced by creating torque and viscous friction whenever a limit angle
        is approached.
    """
        #A prospective feature of this model is that the afferent outputs are
        #normalized in order to produce an output between 0 and 1. In order to
        #normalize the muscle lengths the maximum and minimum length for each
        #muscle are calculated, and reported to the muscle constructor.
        #In order to normalize the velocity and the tension maximum values 
        #would be assumed.
    def __init__(self, ID, params, network):
        """ The class constructor.

            This constructor works by calling the constructor for the planar_arm
            class, and subsequently setting the extra paramters. See
            planar_arm.__init__ for details.

            Args:
                ID, params, network : same as in the planar_arm class except:
                'type' : The enum 'plant_models.bouncy_planar_arm'
                OPTIONAL PARAMETERS
                s_min : minimum shoulder angle in (-pi, pi). Default=-0.3 
                s_max : maximum shoulder angle in (-pi, pi). Default=pi-0.1
                e_min : minimum elbow angle in (-pi, pi). Default=-0.1
                e_max : maximum elbow angle in (-pi, pi). Default= (5/6)*pi
                l_torque : a gain value that multiplies the torques which limit
                           the arm angles. Default is 0.01 .
                l_visco : a gain value that multiplies the viscosity
                          generated by proximity to the limit angles. Default
                          is 0, which makes the arm bouncy.
            Raises:
                ValueErrror
        """
        planar_arm.__init__(self, ID, params, network)
        if 's_min' in params: self.s_min = params['s_min']
        else: self.s_min = -0.3
        if 's_max' in params: self.s_max = params['s_max']
        else: self.s_max = np.pi-0.1
        self.s_range = self.s_max - self.s_min
        if 'e_min' in params: self.e_min = params['e_min']
        else: self.e_min = -0.1
        if 'e_max' in params: self.e_max = params['e_max']
        else: self.e_max = (5./6.)*np.pi
        self.e_range = self.e_max - self.e_min
        if self.s_min < -np.pi or self.s_max > np.pi:
            raise ValueError('Shouler limit angles should be in the ' +
                             '(-pi, pi) interval')
        if self.e_min < -np.pi or self.e_max > np.pi:
            raise ValueError('Elbow limit angles should be in the ' +
                             '(-pi, pi) interval')
        if self.s_range < 0. or self.e_range < 0.:
            raise ValueError('Maximum angle should be larger than minimum angle')
        if self.s_min > params['init_q1'] or self.s_max < params['init_q1']:
            raise ValueError('Initial shoulder angle outside permitted range')
        if self.e_min > params['init_q2'] or self.e_max < params['init_q2']:
            raise ValueError('Initial elbow angle outside permitted range')
        if 'l_torque' in params: self.l_torque = params['l_torque']
        else: self.l_torque = 0.01
        if 'l_visco' in params: self.l_visco = params['l_visco']
        else: self.l_visco = 0.

    def derivatives(self, y, t):
        """ Returns the derivatives of the state variables at a given point in time. 

        Because the muscle model has no differential dynamics, this method only deals
        with the first 4 state variables. This implies that during each integration
        step the muscle tensions are considered to be constant.

        The muscle variables are handled by the custom update methods.
        Inputs to the muscles are appliead in upd_muscle_buffs.
        These equations were copy-pasted from double_pendulum_validation.ipynb .

        Args:
            y : state vector (list-like) ...
                y[0] : angle of shoulder [radians]
                y[1] : angular velocity of shoulder [radians / s]
                y[2] : angle of elbow [radians]
                y[3] : angular velocity of elbow [radians / s]
            t : time at which the derivative is evaluated [s]
        Returns:
            dydt : vector of derivtives (numpy array) ...
                dydt[0] : angular velocity of shoulder [radians / s]
                dydt[1] : angular acceleration of shoulder [radians/s^2]
                dydt[2] : angular velocity of elbow [radians / s]
                dydt[3] : angular acceleration of elbow [radians/s^2]
        """
	# obtaining the muscle torques
        #~~ muscle 1 wrt shouler
        tau1s = self.shoulder_torque(self.ip[0], self.ip[1], self.muscles[0].T)
        #~~ muscle 1 wrt elbow
        tau1e = self.elbow_torque(self.ip[0], self.ip[1], self.muscles[0].T)
	#~~ muscle 2 wrt shoulder
        tau2s = self.shoulder_torque(self.ip[2], self.ip[3], self.muscles[1].T)
	#~~ muscle 3 wrt shoulder
        tau3s = self.shoulder_torque(self.ip[4], self.ip[5], self.muscles[2].T)
	#~~ muscle 4 wrt shoulder
        tau4s = self.shoulder_torque(self.ip[6], self.ip[7], self.muscles[3].T)
	#~~ muscle 4 wrt elbow
        tau4e = self.elbow_torque(self.ip[6], self.ip[7], self.muscles[3].T)
	#~~ muscle 5 wrt elbow
        tau5e = self.elbow_torque(self.ip[8], self.ip[9], self.muscles[4].T)
	#~~ muscle 6 wrt elbow
        tau6e = self.elbow_torque(self.ip[10], self.ip[11], self.muscles[5].T)
        tau1 = tau1s + tau2s + tau3s + tau4s # shoulder torque
        tau2 = tau1e + tau4e + tau5e + tau6e # elbow torque
	# setting shorter names for the variables
        q1 = y[0]
        q1p = y[1]
        q2 = y[2]
        q2p = y[3]
        L1 = self.l_arm
        L2 = self.l_farm
        m1 = self.mass1
        m2 = self.mass2
        g = self.g
        #~~ torques to bound the angles
        a1 = q1-self.s_min # shoulder angle wrt the minimum angle
        l_tau_s1 = (self.l_torque / (abs(a1) + 1e-10))**2
        l_tau_s2 = (self.l_torque / (abs(self.s_range-a1) + 1e-10))**2
        tau1 += l_tau_s1 - l_tau_s2
        a2 = q2-self.e_min # elbow angle wrt the minimum angle
        l_tau_e1 = (self.l_torque / (abs(a2) + 1e-10))**2
        l_tau_e2 = (self.l_torque / (abs(self.e_range-a2) + 1e-10))**2
        tau2 += l_tau_e1 - l_tau_e2
        #~~ extra viscosity to avoid bouncing at the limit angles
        mu1 = self.mu1 + self.l_visco * (l_tau_s1 + l_tau_s2)
        mu2 = self.mu2 + self.l_visco * (l_tau_e1 + l_tau_e2)

        # equations
        dydt = np.zeros_like(y)
        dydt[0] = q1p
        dydt[1] = 3.0*(-2.0*L2*(-2.0*L1*L2*m2*q1p*q2p*sin(q2) - L1*L2*m2*q2p**2*sin(q2) +
                       L1*g*m1*cos(q1) + 2.0*L1*g*m2*cos(q1) + L2*g*m2*cos(q1 + q2) +
                       2.0*mu1*q1p - 2.0*tau1) + (3.0*L1*cos(q2) + 2.0*L2) * 
                       (L1*L2*m2*q1p**2*sin(q2) + L2*g*m2*cos(q1 + q2) +
                       2.0*mu2*q2p - 2.0*tau2)) / ( 
                       L1**2*L2*(4.0*m1 + 9.0*m2*sin(q2)**2 + 3.0*m2))
        dydt[2] = q2p
        dydt[3] = 3.0*(L2*m2*(3.0*L1*cos(q2) + 2.0*L2)*(-2.0*L1*L2*m2*q1p*q2p*sin(q2) -
                       L1*L2*m2*q2p**2*sin(q2) + L1*g*m1*cos(q1) + 2.0*L1*g*m2*cos(q1) +
                       L2*g*m2*cos(q1 + q2) + 2.0*mu1*q1p - 2.0*tau1) -
                       2.0*(L1**2*m1 + 3.0*L1**2*m2 + 3.0*L1*L2*m2*cos(q2) + L2**2*m2) *
                       (L1*L2*m2*q1p**2*sin(q2) + L2*g*m2*cos(q1 + q2) + 2.0*mu2*q2p -
                       2.0*tau2)) / (L1**2*L2**2*m2*(4.0*m1 + 9.0*m2*sin(q2)**2 + 3.0*m2))
        return dydt

    def coords_to_angs(self, coords):
        """ Receives X-Y coordinates, returns angles that put the hand there.

            Args:
                coords : list-like with [x,y] coordinates.
            Returns:
                List [q1, q2], where q1=shoulder angle, q2=elbow angle.
            Raises:
                ValueError
        """
        x = coords[0]
        y = coords[1]
        Rsq = x*x + y*y
        R = np.sqrt(Rsq)
        L1 = self.l_arm
        L2 = self.l_farm
        if R > L1 + L2:
            raise ValueError('Unreachable coordinate given')
        q2 = np.pi - np.arccos((L1**2 + L2**2 - Rsq) / (2.*L1*L2))
        q1 = np.arctan2(y,x) - np.arcsin((L2/R)*np.sin(q2))
        return np.array([q1, q2])

    def coords_to_lengths(self, coords):
        """ Return the muscle lengths when the hand is at given coordinates.

            Args:
                coords : list-like with [x,y] coordinates.
            Returns:
                Numpy array [l0,...,l5] with the lengts of the 6 muscles.
            Raises:
                ValueError
        """
        q1, q2 = self.coords_to_angs(coords)
        # Code replicated from upd_ip
        q12 = q1+q2
        # update coordinates of the elbow and hand
        c_elbow = (self.l_arm*np.cos(q1), self.l_arm*np.sin(q1)) 
        #~~ muscle 1
        ip1 = self.p1 # if this point doesn't rotate
        ip2 = (c_elbow[0] + self.l_i2*np.cos(q12+self.a_i2),
               c_elbow[1] + self.l_i2*np.sin(q12+self.a_i2))
        #~~ muscle 2
        ip3 = self.p3  # if this point doesn't rotate
        ip4 = (self.l_i4*np.cos(q1+self.a_i4), self.l_i4*np.sin(q1+self.a_i4))
        #~~ muscle 3
        ip5 = self.p5 # if this point doesn't rotate
        ip6 = (self.l_i6*np.cos(q1+self.a_i6), self.l_i6*np.sin(q1+self.a_i6))
        #~~ muscle 4
        ip7 = self.p7 # if this point doesn't rotate
        ip8 = (c_elbow[0] - self.l_i8*np.cos(q12-self.a_i8),
               c_elbow[1] - self.l_i8*np.sin(q12-self.a_i8))
        #~~ muscle 5
        ip9 = (self.l_i9*np.cos(q1+self.a_i9), self.l_i9*np.sin(q1+self.a_i9))
        ip10 = (c_elbow[0] + self.l_i10*np.cos(q12+self.a_i10),
                c_elbow[1] + self.l_i10*np.sin(q12+self.a_i10))
        #~~ muscle 6
        ip11 = (self.l_i11*np.cos(q1+self.a_i11), self.l_i11*np.sin(q1+self.a_i11))
        ip12 = (c_elbow[0] - self.l_i12*np.cos(q12-self.a_i12),
                c_elbow[1] - self.l_i12*np.sin(q12-self.a_i12))
        ips = [[ip1, ip2], [ip3,ip4], [ip5,ip6], [ip7,ip8], [ip9,ip10], [ip11,ip12]]
        ips = [[np.array(ip[0]), np.array(ip[1])] for ip in ips]
        lengths = []
        for ipp in ips:
            lengths.append(np.linalg.norm(ipp[0]-ipp[1]))
        return np.array(lengths)


class bouncy_planar_arm_v2(planar_arm_v2):
    """ A version of the planar_arm_v2 with bounded angles.

        For both the shoulder and elbow joints there are maximum and minimum
        angles, set by extra parameters in the constructor. These angles are
        enforced by creating torque and viscous friction whenever a limit angle
        is approached.
    """
    def __init__(self, ID, params, network):
        """ The class constructor.

            This constructor works by calling the constructor for the
            planar_arm_v2 class, and subsequently setting the extra paramters. See
            planar_arm_v2.__init__ for details.

            Args:
                ID, params, network : same as in the planar_arm class except:
                'type' : The enum 'plant_models.bouncy_planar_arm_v2'
                OPTIONAL PARAMETERS
                s_min : minimum shoulder angle in (-pi, pi). Default=-0.3 
                s_max : maximum shoulder angle in (-pi, pi). Default=pi-0.1
                e_min : minimum elbow angle in (-pi, pi). Default=-0.1
                e_max : maximum elbow angle in (-pi, pi). Default= (5/6)*pi
                l_torque : a gain value that multiplies the torques which limit
                           the arm angles. Default is 0.01 .
                l_visco : a gain value that multiplies the viscosity
                          generated by proximity to the limit angles. Default
                          is 0, which makes the arm bouncy.
            Raises:
                ValueErrror
        """
        planar_arm_v2.__init__(self, ID, params, network)
        if 's_min' in params: self.s_min = params['s_min']
        else: self.s_min = -0.3
        if 's_max' in params: self.s_max = params['s_max']
        else: self.s_max = np.pi-0.1
        self.s_range = self.s_max - self.s_min
        if 'e_min' in params: self.e_min = params['e_min']
        else: self.e_min = -0.1
        if 'e_max' in params: self.e_max = params['e_max']
        else: self.e_max = (5./6.)*np.pi
        self.e_range = self.e_max - self.e_min
        if self.s_min < -np.pi or self.s_max > np.pi:
            raise ValueError('Shouler limit angles should be in the ' +
                             '(-pi, pi) interval')
        if self.e_min < -np.pi or self.e_max > np.pi:
            raise ValueError('Elbow limit angles should be in the ' +
                             '(-pi, pi) interval')
        if self.s_range < 0. or self.e_range < 0.:
            raise ValueError('Maximum angle should be larger than minimum angle')
        if self.s_min > params['init_q1'] or self.s_max < params['init_q1']:
            raise ValueError('Initial shoulder angle outside permitted range')
        if self.e_min > params['init_q2'] or self.e_max < params['init_q2']:
            raise ValueError('Initial elbow angle outside permitted range')
        if 'l_torque' in params: self.l_torque = params['l_torque']
        else: self.l_torque = 0.01
        if 'l_visco' in params: self.l_visco = params['l_visco']
        else: self.l_visco = 0.

    def derivatives(self, y, t):
        """ Returns the derivatives of the state variables at a given point in time. 

        At present, the hill_muscle has differential dynamics for one variable
        per muscle (the tension).  With the first 4 state variables
        corresponding to the planar arm angles, we have 10 variables to update. 

        Args:
            y : state vector (list-like) ...
                y[0] : angle of shoulder [radians]
                y[1] : angular speed of shoulder [radians / s]
                y[2] : angle of elbow [radians]
                y[3] : angular speed of elbow [radians / s]
                y[4] : tension for muscle 1 [N]
                y[5] : tension for muscle 2 [N]
                y[6] : tension for muscle 3 [N]
                y[7] : tension for muscle 4 [N]
                y[8] : tension for muscle 5 [N]
                y[9] : tension for muscle 6 [N]
            t : time at which the derivative is evaluated [s]
        Returns:
            dydt : vector of derivtives (numpy array) ...
                dydt[0] : angular speed of shoulder [radians / s]
                dydt[1] : angular acceleration of shoulder [radians/s^2]
                dydt[2] : angular speed of elbow [radians / s]
                dydt[3] : angular acceleration of elbow [radians/s^2]
                dydt[4] : derivative of tension for muscle 1 [N/s]
                dydt[5] : derivative of tension for muscle 2 [N/s]
                dydt[6] : derivative of tension for muscle 3 [N/s]
                dydt[7] : derivative of tension for muscle 4 [N/s]
                dydt[8] : derivative of tension for muscle 5 [N/s]
                dydt[9] : derivative of tension for muscle 6 [N/s]
        """
        dydt = np.zeros_like(y)
        #*** Obtaining geometry information corresponding to current angles
        c_elbow, c_hand, ips = self.upd_ip_impl(y[0], y[2])
        #*** Obtaining muscle velocities given the angular velocities
        m_lengths, m_speeds = self.muscle_kinematics(y[1],y[3], c_elbow, ips)
        #*** Obtaining tension derivatives
        for musc_idx in range(6):
            dydt[4+musc_idx] = self.muscles[musc_idx].tension_deriv(
                                    self.get_input_sum(t, 3*musc_idx),
                                    m_lengths[musc_idx],
                                    m_speeds[musc_idx],
                                    y[4+musc_idx])
	#*** obtaining the muscle torques
        #~~ muscle 1 wrt shouler
        tau1s = self.shoulder_torque(ips[0], ips[1], y[4])
        #~~ muscle 1 wrt elbow
        tau1e = self.elbow_torque(ips[0], ips[1], y[4])
	#~~ muscle 2 wrt shoulder
        tau2s = self.shoulder_torque(ips[2], ips[3], y[5])
	#~~ muscle 3 wrt shoulder
        tau3s = self.shoulder_torque(ips[4], ips[5], y[6])
	#~~ muscle 4 wrt shoulder
        tau4s = self.shoulder_torque(ips[6], ips[7], y[7])
	#~~ muscle 4 wrt elbow
        tau4e = self.elbow_torque(ips[6], ips[7], y[7]) 
	#~~ muscle 5 wrt elbow
        tau5e = self.elbow_torque(ips[8], ips[9], y[8])
	#~~ muscle 6 wrt elbow
        tau6e = self.elbow_torque(ips[10], ips[11], y[9])
        tau1 = tau1s + tau2s + tau3s + tau4s # shoulder torque
        tau2 = tau1e + tau4e + tau5e + tau6e # elbow torque
	#*** setting shorter names for the variables
        q1 = y[0]
        q1p = y[1]
        q2 = y[2]
        q2p = y[3]
        L1 = self.l_arm
        L2 = self.l_farm
        m1 = self.mass1
        m2 = self.mass2
        g = self.g
        #*** torques to bound the angles
        a1 = q1-self.s_min # shoulder angle wrt the minimum angle
        l_tau_s1 = (self.l_torque / (abs(a1) + 1e-10))**2
        l_tau_s2 = (self.l_torque / (abs(self.s_range-a1) + 1e-10))**2
        tau1 += l_tau_s1 - l_tau_s2
        a2 = q2-self.e_min # elbow angle wrt the minimum angle
        l_tau_e1 = (self.l_torque / (abs(a2) + 1e-10))**2
        l_tau_e2 = (self.l_torque / (abs(self.e_range-a2) + 1e-10))**2
        tau2 += l_tau_e1 - l_tau_e2
        #~~ extra viscosity to avoid bouncing at the limit angles
        mu1 = self.mu1 + self.l_visco * (l_tau_s1 + l_tau_s2)
        mu2 = self.mu2 + self.l_visco * (l_tau_e1 + l_tau_e2)

        #*** angular acceleration equations
        dydt[0] = q1p
        dydt[1] = 3.0*(-2.0*L2*(-2.0*L1*L2*m2*q1p*q2p*sin(q2) - L1*L2*m2*q2p**2*sin(q2) +
                       L1*g*m1*cos(q1) + 2.0*L1*g*m2*cos(q1) + L2*g*m2*cos(q1 + q2) +
                       2.0*mu1*q1p - 2.0*tau1) + (3.0*L1*cos(q2) + 2.0*L2) * 
                       (L1*L2*m2*q1p**2*sin(q2) + L2*g*m2*cos(q1 + q2) +
                       2.0*mu2*q2p - 2.0*tau2)) / ( 
                       L1**2*L2*(4.0*m1 + 9.0*m2*sin(q2)**2 + 3.0*m2))
        dydt[2] = q2p
        dydt[3] = 3.0*(L2*m2*(3.0*L1*cos(q2) + 2.0*L2)*(-2.0*L1*L2*m2*q1p*q2p*sin(q2) -
                       L1*L2*m2*q2p**2*sin(q2) + L1*g*m1*cos(q1) + 2.0*L1*g*m2*cos(q1) +
                       L2*g*m2*cos(q1 + q2) + 2.0*mu1*q1p - 2.0*tau1) -
                       2.0*(L1**2*m1 + 3.0*L1**2*m2 + 3.0*L1*L2*m2*cos(q2) + L2**2*m2) *
                       (L1*L2*m2*q1p**2*sin(q2) + L2*g*m2*cos(q1 + q2) + 2.0*mu2*q2p -
                       2.0*tau2)) / (L1**2*L2**2*m2*(4.0*m1 + 9.0*m2*sin(q2)**2 + 3.0*m2))
        return dydt

    def coords_to_angs(self, coords):
        """ Receives X-Y coordinates, returns angles that put the hand there.

            Args:
                coords : list-like with [x,y] coordinates.
            Returns:
                List [q1, q2], where q1=shoulder angle, q2=elbow angle.
            Raises:
                ValueError
        """
        x = coords[0]
        y = coords[1]
        Rsq = x*x + y*y
        R = np.sqrt(Rsq)
        L1 = self.l_arm
        L2 = self.l_farm
        if R > L1 + L2:
            raise ValueError('Unreachable coordinate given')
        q2 = np.pi - np.arccos((L1**2 + L2**2 - Rsq) / (2.*L1*L2))
        q1 = np.arctan2(y,x) - np.arcsin((L2/R)*np.sin(q2))
        return np.array([q1, q2])

    def coords_to_lengths(self, coords):
        """ Return the muscle lengths when the hand is at given coordinates.

            Args:
                coords : list-like with [x,y] coordinates.
            Returns:
                Numpy array [l0,...,l5] with the lengts of the 6 muscles.
            Raises:
                ValueError
        """
        q1, q2 = self.coords_to_angs(coords)
        _, _, ips = self.upd_ip_impl(q1, q2)
        lengths = []
        for idx in range(0,11,2):
            lengths.append(np.linalg.norm(ips[idx]-ips[idx+1]))
        return np.array(lengths)


class bouncy_planar_arm_v3(planar_arm_v3):
    """ A version of the planar_arm_v3 with bounded angles.

        For both the shoulder and elbow joints there are maximum and minimum
        angles, set by extra parameters in the constructor. These angles are
        enforced by creating torque and viscous friction whenever a limit angle
        is approached.
    """
    def __init__(self, ID, params, network):
        """ The class constructor.

            This constructor works by calling the constructor for the
            planar_arm_v3 class, and subsequently setting the extra paramters. See
            planar_arm_v3.__init__ for details.

            Args:
                ID, params, network : same as in the planar_arm_v3 class except:
                'type' : The enum 'plant_models.bouncy_planar_arm_v3'
                OPTIONAL PARAMETERS
                s_min : minimum shoulder angle in (-pi, pi). Default=-0.3 
                s_max : maximum shoulder angle in (-pi, pi). Default=pi-0.1
                e_min : minimum elbow angle in (-pi, pi). Default=-0.1
                e_max : maximum elbow angle in (-pi, pi). Default= (5/6)*pi
                l_torque : a gain value that multiplies the torques which limit
                           the arm angles. Default is 0.01 .
                l_visco : a gain value that multiplies the viscosity
                          generated by proximity to the limit angles. Default
                          is 0, which makes the arm bouncy.
            Raises:
                ValueErrror
        """
        planar_arm_v3.__init__(self, ID, params, network)
        if 's_min' in params: self.s_min = params['s_min']
        else: self.s_min = -0.3
        if 's_max' in params: self.s_max = params['s_max']
        else: self.s_max = np.pi-0.1
        self.s_range = self.s_max - self.s_min
        if 'e_min' in params: self.e_min = params['e_min']
        else: self.e_min = -0.1
        if 'e_max' in params: self.e_max = params['e_max']
        else: self.e_max = (5./6.)*np.pi
        self.e_range = self.e_max - self.e_min
        if self.s_min < -np.pi or self.s_max > np.pi:
            raise ValueError('Shouler limit angles should be in the ' +
                             '(-pi, pi) interval')
        if self.e_min < -np.pi or self.e_max > np.pi:
            raise ValueError('Elbow limit angles should be in the ' +
                             '(-pi, pi) interval')
        if self.s_range < 0. or self.e_range < 0.:
            raise ValueError('Maximum angle should be larger than minimum angle')
        if self.s_min > params['init_q1'] or self.s_max < params['init_q1']:
            raise ValueError('Initial shoulder angle outside permitted range')
        if self.e_min > params['init_q2'] or self.e_max < params['init_q2']:
            raise ValueError('Initial elbow angle outside permitted range')
        if 'l_torque' in params: self.l_torque = params['l_torque']
        else: self.l_torque = 0.01
        if 'l_visco' in params: self.l_visco = params['l_visco']
        else: self.l_visco = 0.

    def derivatives(self, y, t):
        """ Returns the derivatives of the state variables at time t. 

        There are 4 dynamical variables to update per muscle, corresponging to
        the 3 tensions (one extrafusal two intrafusals), and Ib afferent rate.
        Together with the 4 state variables of the double pendulum, there are 
        28 variables to differentiate. The Ia and II outputs are handled by the
        update function.
        
        Args:
            y : state vector (list-like) ...
                y[0] : angle of shoulder [radians]
                y[1] : angular speed of shoulder [radians / s]
                y[2] : angle of elbow [radians]
                y[3] : angular speed of elbow [radians / s]
                y[4]-y[9] : tensions for muscles 1-6 [N]
                y[10]-y[15]: tensions for dynamic fibers, muscles 1-6
                y[16]-y[21]: tensions for static fibers, muscles 1-6
                y[22]-y[27]: Ib afferent activities for muscles 1-6
            t : time at which the derivative is evaluated [s]
        Returns:
            dydt : vector of derivatives (numpy array)
                dydt[0] : angular speed of shoulder [radians / s]
                dydt[1] : angular acceleration of shoulder [radians/s^2]
                dydt[2] : angular speed of elbow [radians / s]
                dydt[3] : angular acceleration of elbow [radians/s^2]
                dydt[4-9] : tension derivatives for muscles 1-6 [N/s]
                dydt[10-15]: tension derivatives for dynamic fibers 1-6
                dydt[16-21]: tension derivatives for static fibers 1-6
                dydt[22-27]: derivatives of Ib activity for muscles 1-6
        """
        dydt = np.zeros_like(y)
        #*** geometry information corresponding to current angles
        c_elbow, c_hand, ips = self.upd_ip_impl(y[0], y[2])
        #*** muscle velocities given the angular velocities
        lengths, speeds = self.muscle_kinematics(y[1],y[3], c_elbow, ips)
        #*** tension derivatives for the muscles
        dydt[4:22] = self.tension_diff(lengths, speeds, y[4:22], t)
	#*** muscle torques
        #~~ muscle 1 wrt shouler
        tau1s = self.shoulder_torque(ips[0], ips[1], y[4])
        #~~ muscle 1 wrt elbow
        tau1e = self.elbow_torque(ips[0], ips[1], y[4])
	#~~ muscle 2 wrt shoulder
        tau2s = self.shoulder_torque(ips[2], ips[3], y[5])
	#~~ muscle 3 wrt shoulder
        tau3s = self.shoulder_torque(ips[4], ips[5], y[6])
	#~~ muscle 4 wrt shoulder
        tau4s = self.shoulder_torque(ips[6], ips[7], y[7])
	#~~ muscle 4 wrt elbow
        tau4e = self.elbow_torque(ips[6], ips[7], y[7]) 
	#~~ muscle 5 wrt elbow
        tau5e = self.elbow_torque(ips[8], ips[9], y[8])
	#~~ muscle 6 wrt elbow
        tau6e = self.elbow_torque(ips[10], ips[11], y[9])
        tau1 = tau1s + tau2s + tau3s + tau4s # shoulder torque
        tau2 = tau1e + tau4e + tau5e + tau6e # elbow torque
        #*** set shorter names for the variables
        q1 = y[0]
        q1p = y[1]
        q2 = y[2]
        q2p = y[3]
        L1 = self.l_arm
        L2 = self.l_farm
        m1 = self.mass1
        m2 = self.mass2
        g = self.g
        #*** torques to bound the angles
        a1 = q1-self.s_min # shoulder angle wrt the minimum angle
        l_tau_s1 = (self.l_torque / (abs(a1) + 1e-10))**2
        l_tau_s2 = (self.l_torque / (abs(self.s_range-a1) + 1e-10))**2
        tau1 += l_tau_s1 - l_tau_s2
        a2 = q2-self.e_min # elbow angle wrt the minimum angle
        l_tau_e1 = (self.l_torque / (abs(a2) + 1e-10))**2
        l_tau_e2 = (self.l_torque / (abs(self.e_range-a2) + 1e-10))**2
        tau2 += l_tau_e1 - l_tau_e2
        #~~ extra viscosity to avoid bouncing at the limit angles
        mu1 = self.mu1 + self.l_visco * (l_tau_s1 + l_tau_s2)
        mu2 = self.mu2 + self.l_visco * (l_tau_e1 + l_tau_e2)

        #*** angular acceleration equations
        dydt[0] = q1p
        dydt[1] = 3.0*(-2.0*L2*(-2.0*L1*L2*m2*q1p*q2p*sin(q2) - L1*L2*m2*q2p**2*sin(q2) +
                       L1*g*m1*cos(q1) + 2.0*L1*g*m2*cos(q1) + L2*g*m2*cos(q1 + q2) +
                       2.0*mu1*q1p - 2.0*tau1) + (3.0*L1*cos(q2) + 2.0*L2) * 
                       (L1*L2*m2*q1p**2*sin(q2) + L2*g*m2*cos(q1 + q2) +
                       2.0*mu2*q2p - 2.0*tau2)) / ( 
                       L1**2*L2*(4.0*m1 + 9.0*m2*sin(q2)**2 + 3.0*m2))
        dydt[2] = q2p
        dydt[3] = 3.0*(L2*m2*(3.0*L1*cos(q2) + 2.0*L2)*(-2.0*L1*L2*m2*q1p*q2p*sin(q2) -
                       L1*L2*m2*q2p**2*sin(q2) + L1*g*m1*cos(q1) + 2.0*L1*g*m2*cos(q1) +
                       L2*g*m2*cos(q1 + q2) + 2.0*mu1*q1p - 2.0*tau1) -
                       2.0*(L1**2*m1 + 3.0*L1**2*m2 + 3.0*L1*L2*m2*cos(q2) + L2**2*m2) *
                       (L1*L2*m2*q1p**2*sin(q2) + L2*g*m2*cos(q1 + q2) + 2.0*mu2*q2p -
                       2.0*tau2)) / (L1**2*L2**2*m2*(4.0*m1 + 9.0*m2*sin(q2)**2 + 3.0*m2))
       #*** Tension derivatives for the GTOs
        r_ss = self.m_params['Ib_gain'] * np.log(
                          np.maximum(y[4:10], 0.) / self.m_params['T_0'] + 1.)
        dydt[22:28] = (r_ss - y[22:28]) / self.m_params['tau_g']
        return dydt

    def coords_to_angs(self, coords):
        """ Receives X-Y coordinates, returns angles that put the hand there.

            Args:
                coords : list-like with [x,y] coordinates.
            Returns:
                List [q1, q2], where q1=shoulder angle, q2=elbow angle.
            Raises:
                ValueError
        """
        x = coords[0]
        y = coords[1]
        Rsq = x*x + y*y
        R = np.sqrt(Rsq)
        L1 = self.l_arm
        L2 = self.l_farm
        if R > L1 + L2:
            raise ValueError('Unreachable coordinate given')
        q2 = np.pi - np.arccos((L1**2 + L2**2 - Rsq) / (2.*L1*L2))
        q1 = np.arctan2(y,x) - np.arcsin((L2/R)*np.sin(q2))
        return np.array([q1, q2])

    def coords_to_lengths(self, coords):
        """ Return the muscle lengths when the hand is at given coordinates.

            Args:
                coords : list-like with [x,y] coordinates.
            Returns:
                Numpy array [l0,...,l5] with the lengts of the 6 muscles.
            Raises:
                ValueError
        """
        q1, q2 = self.coords_to_angs(coords)
        _, _, ips = self.upd_ip_impl(q1, q2)
        lengths = []
        for idx in range(0,11,2):
            lengths.append(np.linalg.norm(ips[idx]-ips[idx+1]))
        return np.array(lengths)

