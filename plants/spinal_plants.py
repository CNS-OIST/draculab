"""
spinal_plants.py
The plant models specially adapted for the spinal model.
"""
from draculab import unit_types, synapse_types, syn_reqs 
#from units.units import unit, sigmoidal
from plants.plants import plant, pendulum, spring_muscle, planar_arm
import numpy as np
from numpy import sin, cos # for the double pendulum equations

class bouncy_pendulum(pendulum):
    """ 
    A pendulum that bounces away when its angle approaches pi.

    This is a variation of the pendulum class with a modified derivatives
    function. It causes a torque that bounces the pendulum away when its angle
    approaches pi radians. It can also be made less bouncy by increasing the
    viscous friction coefficient as the angle approaches pi. This behaviour
    depends on a parameter called pi_visco.

    PENDULUM DOCSTRING:
    Model of a rigid, homogeneous rod with a 1-dimensional rotational joint at one end.

    The simplest model of an arm is a rigid rod with one end attached to a rotational
    joint with 1 degree of freedom. Like a rigid pendulum, but the gravity vector is
    optional. 
    There is no extra mass at the end of the rod; the center of mass is at length/2 .
    
    On the XY plane the joint is at the origin, the positive X direction
    aligns with zero degrees, and gravity points in the negative Y direction.
    Counterclockwise rotation and torques are positive. Angles are in radians, time is
    in seconds.

    The equation of motion used is: I a = (mgL/2)cos(theta) - mu v + T
    where I=inertia moment about axis of rotation, a=angular acceleration, g=gravity constant,
    L=length of rod, theta=pendulum angle, mu=viscous friction coefficeint, m=mass of rod, 
    v=angular velocity, T=external torque.

    Inputs to the model at port 0 are torques applied at the joint. Other ports are ignored.

    The get_state(time) function returns the two state variables of the model in a numpy 
    array. Angle has index 0, and angular velocity has index 1. The 'time' argument
    should be in the interval [sim_time - del, sim_time], where sim_time is the current
    simulation time (time of last simulation step), and del is the 'delay' value
    of the plant. This method can be configured to provide angles in the 
    [-pi, pi) interval by using the 'bound_angle' parameter.

    Alternatively, the state variables can be retrieved with the get_angle(t) and
    get_ang_vel(t) functions.
    """
    def __init__(self, ID, params, network):
        """ The class constructor, called by network.create_plant .

        Args:
            ID: An integer serving as a unique identifier in the network.
            params: A dictionary with parameters to initialize the model.
                REQUIRED PARAMETERS
                'type' : A model from the plant_models enum.
                'length' : length of the rod [m]
                'mass' : mass of the rod [kg]
                'init_angle' : initial angle of the rod. [rad]
                'init_ang_vel' : initial angular velocity of the rod. [rad/s]
                OPTIONAL PARAMETERS
                'g' : gravitational acceleration constant. [m/s^2] (Default: 9.8)
                'inp_gain' : A gain value that multiplies the inputs. (Default: 1)
                'mu' : A viscous friction coefficient. (Default: 0)
                'bound_angle' : If True, the angle communicated through the output
                                ports is in the interval [-pi, pi). False by default.
                'pi_visco' : a gain value that multiplies the viscosity
                             generated by proximity to the angle pi. Default is 
                             0, which makes the arm bouncy.
            network: the network where the plant instance lives.

        Raises:
            AssertionError.

        """
        pendulum.__init__(self, ID, params, network)
        if 'pi_visco' in params:
            self.pi_visco = params['pi_visco']
        else:
            self.pi_visco = 0.
 
    def derivatives(self, y, t):
        """ Returns the derivatives of the state variables at a given point in time. 

	Args:
            y[0] = angle [radians]
            y[1] = angular velocity [radians / s]
            t = time at which the derivative is evaluated [s]
        Returns:
            2-element 1D Numpy array with angular velocity and acceleration.
        """
        # the inputs generate torque
        torque = self.inp_gain * self.get_input_sum(t,0)
        # torque will also appear when angle is close to pi
        torque -= (np.tan((y[0]%(2.*np.pi))/2.)/10.)**3
        # extra viscosity appears close to pi
        mupi = self.pi_visco / (((y[0]+np.pi)%(2.*np.pi))**2 + 1e-5)
        # torque may also come from gravity and friction
        torque -= self.c * np.cos(y[0]) +  (self.mu + mupi) * y[1]
        # angular acceleration = torque / (inertia moment)
        ang_accel = torque / self.I
        return np.array([y[1], ang_accel])


class bouncy_planar_arm(planar_arm):
    """ A version of the planar arm with bounded angles.

        For both the shoulder and elbow joints there are maximum and minimum
        angles, set by extra parameters in the constructor. These angles are
        enforced by creating torque and viscous friction whenever a limit angle
        is approached.
    """
    def __init__(self, ID, params, network):
        """ The class constructor.

            This constructor works by calling the constructor for the planar_arm
            class, and subsequently setting the extra paramters. See
            planar_arm.__init__ for details.

            Args:
                ID, params, network : same as in the planar_arm class
                OPTIONAL PARAMETERS
                s_min : minimum shoulder angle in (-pi, pi). Default=-0.3 
                s_max : maximum shoulder angle in (-pi, pi). Default=pi-0.1
                e_min : minimum elbow angle in (-pi, pi). Default=-0.1
                e_max : maximum elbow angle in (-pi, pi). Default= (5/6)*pi
                l_torque : a gain value that multiplies the torques which limit
                           the arm angles. Default is 0.01 .
                l_visco : a gain value that multiplies the viscosity
                          generated by proximity to the limit angles. Default
                          is 0, which makes the arm bouncy.
            Raises:
                ValueErrror
        """
        planar_arm.__init__(self, ID, params, network)
        if 's_min' in params: self.s_min = params['s_min']
        else: self.s_min = -0.3
        if 's_max' in params: self.s_max = params['s_max']
        else: self.s_max = np.pi-0.1
        self.s_range = self.s_max - self.s_min
        if 'e_min' in params: self.e_min = params['e_min']
        else: self.e_min = -0.1
        if 'e_max' in params: self.e_max = params['e_max']
        else: self.e_max = (5./6.)*np.pi
        self.e_range = self.e_max - self.e_min
        if self.s_min < -np.pi or self.s_max > np.pi:
            raise ValueError('Shouler limit angles should be in the ' +
                             '(-pi, pi) interval')
        if self.e_min < -np.pi or self.e_max > np.pi:
            raise ValueError('Elbow limit angles should be in the ' +
                             '(-pi, pi) interval')
        if self.s_range < 0. or self.e_range < 0.:
            raise ValueError('Maximum angle should be larger than minimum angle')
        if self.s_min > params['init_q1'] or self.s_max < params['init_q1']:
            raise ValueError('Initial shoulder angle outside permitted range')
        if self.e_min > params['init_q2'] or self.e_max < params['init_q2']:
            raise ValueError('Initial elbow angle outside permitted range')
        if 'l_torque' in params: self.l_torque = params['l_torque ']
        else: self.l_torque = 0.01
        if 'l_visco' in params: self.l_visco = params['l_visco']
        else: self.l_visco = 0.

    def derivatives(self, y, t):
        """ Returns the derivatives of the state variables at a given point in time. 

        Because the muscle model has no differential dynamics, this method only deals
        with the first 4 state variables. This implies that during each integration
        step the muscle tensions are considered to be constant.

        The muscle variables are handled by the custom update methods.
        Inputs to the muscles are appliead in upd_muscle_buffs.
        These equations were copy-pasted from double_pendulum_validation.ipynb .

        Args:
            y : state vector (list-like) ...
                y[0] : angle of shoulder [radians]
                y[1] : angular velocity of shoulder [radians / s]
                y[2] : angle of elbow [radians]
                y[3] : angular velocity of elbow [radians / s]
            t : time at which the derivative is evaluated [s]
        Returns:
            dydt : vector of derivtives (numpy array) ...
                dydt[0] : angular velocity of shoulder [radians / s]
                dydt[1] : angular acceleration of shoulder [radians/s^2]
                dydt[2] : angular velocity of elbow [radians / s]
                dydt[3] : angular acceleration of elbow [radians/s^2]
        """
	# obtaining the muscle torques
        #~~ muscle 1 wrt shouler
        tau1s = self.shoulder_torque(self.ip[0], self.ip[1], self.muscles[0].T)
        #~~ muscle 1 wrt elbow
        tau1e = self.elbow_torque(self.ip[0], self.ip[1], self.muscles[0].T)
	#~~ muscle 2 wrt shoulder
        tau2s = self.shoulder_torque(self.ip[2], self.ip[3], self.muscles[1].T)
	#~~ muscle 3 wrt shoulder
        tau3s = self.shoulder_torque(self.ip[4], self.ip[5], self.muscles[2].T)
	#~~ muscle 4 wrt shoulder
        tau4s = self.shoulder_torque(self.ip[6], self.ip[7], self.muscles[3].T)
	#~~ muscle 4 wrt elbow
        tau4e = self.elbow_torque(self.ip[6], self.ip[7], self.muscles[3].T)
	#~~ muscle 5 wrt elbow
        tau5e = self.elbow_torque(self.ip[8], self.ip[9], self.muscles[4].T)
	#~~ muscle 6 wrt elbow
        tau6e = self.elbow_torque(self.ip[10], self.ip[11], self.muscles[5].T)
        tau1 = tau1s + tau2s + tau3s + tau4s # shoulder torque
        tau2 = tau1e + tau4e + tau5e + tau6e # elbow torque
	# setting shorter names for the variables
        q1 = y[0]
        q1p = y[1]
        q2 = y[2]
        q2p = y[3]
        L1 = self.l_arm
        L2 = self.l_farm
        m1 = self.mass1
        m2 = self.mass2
        g = self.g
        #~~ torques to bound the angles
        a1 = q1-self.s_min # shoulder angle wrt the minimum angle
        l_tau_s1 = (self.l_torque / (abs(a1) + 1e-10))**2
        l_tau_s2 = (self.l_torque / (abs(self.s_range-a1) + 1e-10))**2
        tau1 += l_tau_s1 - l_tau_s2
        a2 = q2-self.e_min # elbow angle wrt the minimum angle
        l_tau_e1 = (self.l_torque / (abs(a2) + 1e-10))**2
        l_tau_e2 = (self.l_torque / (abs(self.e_range-a2) + 1e-10))**2
        tau2 += l_tau_e1 - l_tau_e2
        #~~ extra viscosity to avoid bouncing at the limit angles
        mu1 = self.mu1 + self.l_visco * (l_tau_s1 + l_tau_s2)
        mu2 = self.mu2 + self.l_visco * (l_tau_e1 + l_tau_e2)

        # equations
        dydt = np.zeros_like(y)
        dydt[0] = q1p
        dydt[1] = 3.0*(-2.0*L2*(-2.0*L1*L2*m2*q1p*q2p*sin(q2) - L1*L2*m2*q2p**2*sin(q2) +
                       L1*g*m1*cos(q1) + 2.0*L1*g*m2*cos(q1) + L2*g*m2*cos(q1 + q2) +
                       2.0*mu1*q1p - 2.0*tau1) + (3.0*L1*cos(q2) + 2.0*L2) * 
                       (L1*L2*m2*q1p**2*sin(q2) + L2*g*m2*cos(q1 + q2) +
                       2.0*mu2*q2p - 2.0*tau2)) / ( 
                       L1**2*L2*(4.0*m1 + 9.0*m2*sin(q2)**2 + 3.0*m2))
        dydt[2] = q2p
        dydt[3] = 3.0*(L2*m2*(3.0*L1*cos(q2) + 2.0*L2)*(-2.0*L1*L2*m2*q1p*q2p*sin(q2) -
                       L1*L2*m2*q2p**2*sin(q2) + L1*g*m1*cos(q1) + 2.0*L1*g*m2*cos(q1) +
                       L2*g*m2*cos(q1 + q2) + 2.0*mu1*q1p - 2.0*tau1) -
                       2.0*(L1**2*m1 + 3.0*L1**2*m2 + 3.0*L1*L2*m2*cos(q2) + L2**2*m2) *
                       (L1*L2*m2*q1p**2*sin(q2) + L2*g*m2*cos(q1 + q2) + 2.0*mu2*q2p -
                       2.0*tau2)) / (L1**2*L2**2*m2*(4.0*m1 + 9.0*m2*sin(q2)**2 + 3.0*m2))
        return dydt



